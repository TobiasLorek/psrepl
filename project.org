#+title: An Powershell Repl for Emacs using the Windows terminal

The aim of this project is to setup functionality to let emacs interact with powershell running in Windows Terminal.
1. [ ] Send input to a running Windows Terminal with an powershell shell.
2. [ ] Use `eval/send-reigon-to-repl` to send text to a WT Powershell repl
3. [ ] Set breakpoints in the WT PS Repl using the current location in the file
4. [ ] Import the file into the WT PS Repl

 The Non-Goals of this project are:
5. To write  a pure elisp plugin.
6. To be completely self contained. It is ok if some manual tweaking is required every time you run it.

* First Iteration
** Sending lines to a running powershell process in windows terminal
I am hoping this is possible using powershell, so lets ask the AI to write it for us.

#+begin_src markdown
[SYS]: You are a powershell developer

[ME]: Hi. Write a powershell function that writes an array of strings to the console of an other running powershell instance. The function should take an array of strings and an integer with the PID to the other powershell process as input. It should aquire the stdin handle to the powershell process and post the strings in the array one by one. Then it should release the stdin handle and detach from the process.

[AI]: Sure, here's an example function that should do what you're asking for:

```
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true)]
        [int]$ProcessId
    )

    Begin {
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = "powershell.exe"
        $psi.RedirectStandardInput = $true
        $psi.UseShellExecute = $false
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }
    
    Process {
        foreach ($string in $StringsToSend) {
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($string)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}
```

Here's how you can use the function:

1. Get the process Id of the other PowerShell process that you want to send the strings to. You can do this by opening Task Manager, right-clicking on the PowerShell process, and selecting "Go to details". The process Id is listed under the "Details" tab.

2. Open a PowerShell console and call the `Send-StringsToProcess` function with the array of strings you want to send and the process Id of the other PowerShell process:

```
$strings = @("String 1", "String 2", "String 3")
Send-StringsToProcess -StringsToSend $strings -ProcessId <other PowerShell process Id>
```

This should write each string in the array to the other PowerShell process's console window one by one.

Note that the other PowerShell process must be running as an interactive console application for this to work. If it's running in a non-interactive mode, such as from a scheduled task or Windows service, it won't have a stdin handle that can be written to.

[ME]: Thanks!

[AI]: You're welcome! Let me know if you have any other PowerShell questions or needs.

[ME]: Oh, and the script should be able to pick up the strings as command line arguments

[AI]: Sure, no problem. Here is an updated version of the `Send-StringsToProcess` function that can accept strings as command line arguments:

```
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = "powershell.exe"
        $psi.RedirectStandardInput = $true
        $psi.UseShellExecute = $false
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }
    
    Process {
        $strings = $StringsToSend[0].Split(" ")
        foreach ($string in $strings) {
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($string)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}
```

This updated function accepts input from the pipeline and splits the strings on white space to generate an array of strings that you can use to send to the other PowerShell process. Here is an example of how you can use the updated function:

`"Hello World" | Send-StringsToProcess -ProcessId <other PowerShell process Id>`

This example sends the string "Hello World" to the other PowerShell process. 

You can also use the `-StringsToSend` parameter as before:

```
Send-StringsToProcess -StringsToSend "Hello World" -ProcessId <other PowerShell process Id>
```

This example also sends the string "Hello World" to the other PowerShell process. 

Note that the same caveat applies as before regarding the other PowerShell process needing to be running as an interactive console application.

#+end_src

Well that does look promising but I think it will require some tweaking to get it working.

#+begin_src powershell
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = "powershell.exe"
        $psi.RedirectStandardInput = $true
        $psi.UseShellExecute = $false
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        $strings = $StringsToSend[0].Split(" ")
        foreach ($string in $strings) {
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($string)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}
#+end_src

** Use `eval/send-region-to-repl` to send text to a WT Powershell repl
Ok, next up we need to send it some data. But first I think we need to store the PID somewhere.

#+begin_src markdown
[SYS]: You are an elisp developer

[ME]: Write an elisp function with stores the value if PID in the variable psrepl/pid so that it can be accessible by other functions

[AI]: Here is an elisp function that stores the value of PID in the variable `psrepl/pid`:

```elisp
(defun psrepl/set-pid (pid)
  "Set PID as the psrepl process ID."
  (setq psrepl/pid))
```

This function takes one argument `pid` and sets it as the value of the variable `psrepl/pid`. You can call this function from other functions to store the value of PID, making it easily accessible for other parts of your code.

[ME]: Thanks
#+end_src

Alright. With that taken care we need a function that can call the powershell script, with the PID and send a list of strings to it.

#+begin_src markdown
[SYS]: You are an elisp developer

[ME]: Write me an elisp function which takes a list of strings and invokes the powershell script WriteToPsRepl.ps1 passing the strings as arguments. If possible we should not wait for it to finish

[AI]: Here's an elisp function that takes a list of strings and invokes the `WriteToPsRepl.ps1` PowerShell script passing the strings as arguments without waiting for it to finish:

```elisp
(defun run-ps-script-async (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (cmd (format "powershell.exe -File \"%s\" %s" script
                      (mapconcat 'identity args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))
```

To use this function, simply call it with a list of strings:

```elisp
(run-ps-script-async '("arg1" "arg2" "arg3"))
``` 

This will start the PowerShell process asynchronously and execute the script in the background passing the given arguments.

[ME]: Thanks
#+end_src

Ok, we are making progress! Next up, and this i suspect will be difficult, is to hijack the eval/send-region-to-repl to use our function instead.

#+begin_src markdown
[SYS]: You are an elisp developer

[ME]: I need to change the behavior of the function eval/send-reigon-to-repl so that it send the lines as a list of strings to the function psrepl/send-to-powershell. But only when the major mode is powershell-mode

[AI]: You can modify the behavior of the `eval/send-region-to-repl` function in Emacs Lisp to suit your needs by defining an advice function that intercepts the call to this function and modifies its behavior based on the current major mode.

Here's an example advice function that you can use to achieve the desired behavior:

``` emacs-lisp
(defun my/eval-region-to-powershell (orig-fun &rest args)
  "Advice function to modify behavior of `eval/send-region-to-repl'.

   This function intercepts the call to `eval/send-region-to-repl' and
   modifies its behavior to send the lines as a list of strings to the
   function `psrepl/send-to-powershell' only when the major mode is
   `powershell-mode'. Otherwise, it delegates to the original function."
  (if (eq major-mode 'powershell-mode)
      (let ((region-str (buffer-substring-no-properties
                         (region-beginning) (region-end))))
        (psrepl/send-to-powershell (split-string region-str "\n")))
    (apply orig-fun args)))
```

This advice function checks if the current major mode is `powershell-mode`. If it is, then it retrieves the region text and sends each line as a separate string to the `psrepl/send-to-powershell` function using the `split-string` function to split the region text into a list of lines. Otherwise, it delegates to the original function.

You can use this function by adding the advice to the `eval/send-region-to-repl` function:

``` emacs-lisp
(advice-add 'eval/send-region-to-repl :around #'my/eval-region-to-powershell)
```

This will modify the behavior of the `eval/send-region-to-repl` function to behave as you intended only when the major mode is `powershell-mode`.

[ME]: Thanks!

[AI]: You're welcome! Let me know if you have any further questions or need further assistance.

[ME]: 
#+end_src


Ok, It looks like we are almost there! all in about 30 minutes using ChatGPT

** Working with scripts. Setting breakpoints and inclusing them
Ok, so next up it setting breakpoints and including the script source. This should be fairly straight forward. For the break point we need the current line and the script name. Then we just send the string "Set-PSBreakPoint -Line 'current line' -Script 'current file'"
Including the file is even simpler. Just send the string ". path-to-script.ps"

#+begin_src markdown
[SYS]: You are an elisp developer

[ME]: Write me an elisp function called psrepl/set-breakpoint which takes a line number, called `linenum` and a filename called `filename` as arguments and the calls the function
psrepl/send-to-powershell with a list containing the single string "Set-PSBreakpoint -Line `linenum` -Script `filename`"

[AI]: Here's an implementation of `psrepl/set-breakpoint` function:

```elisp
(defun psrepl/set-breakpoint (linenum filename)
  "Sets a breakpoint at LINENUM in FILENAME using `Set-PSBreakpoint` cmdlet."
  (psrepl/send-to-powershell
   (list (format "Set-PSBreakpoint -Line %d -Script \"%s\"" linenum filename))))
```

This function simply formats the `Set-PSBreakpoint` cmdlet using the given `linenum` and `filename` arguments, and sends it to the PowerShell REPL using `psrepl/send-to-powershell` function. 

You can use this function like this:

```elisp
(psrepl/set-breakpoint 42 "myscript.ps1")
```

This will set a breakpoint at line 42 of `myscript.ps1` file.

[ME]: Thats create. Now write me a new elisp function called psrepl/set-breakpoint-here which calles psrepl/set-breakpoint with the cursors line number as `linenum` and the current file as `filename`

[AI]: Sure, here's the implementation of `psrepl/set-breakpoint-here` function that uses `psrepl/set-breakpoint` function internally:

```elisp
(defun psrepl/set-breakpoint-here ()
  "Sets a breakpoint at the current cursor position in the current buffer using `Set-PSBreakpoint` cmdlet."
  (interactive)
  (let ((linenum (line-number-at-pos))
        (filename (buffer-file-name)))
    (when filename
      (psrepl/set-breakpoint linenum filename))))
```

This function first gets the current line number using `line-number-at-pos` function, and the current file name using `buffer-file-name` function. If the file name is not `nil`, it calls `psrepl/set-breakpoint` with these arguments.

You can bind this function to a keybinding in your Emacs configuration file like this:

```elisp
(global-set-key (kbd "C-c C-b") #'psrepl/set-breakpoint-here)
```

This binds the `psrepl/set-breakpoint-here` function to the `C-c C-b` keybinding, so you can use it to set breakpoints quickly.

[ME]: Alright. Finally, write me an emacs function with calls psrepl/send-to-powershell with a list containing only one string `. filepath` where filepath is the full path to the current file

[AI]: Sure, here's the implementation of `psrepl/open-current-file` function that uses `psrepl/send-to-powershell` function to open the current file in the PowerShell REPL:

```elisp
(defun psrepl/open-current-file ()
  "Opens the current file in the PowerShell REPL using `.` operator."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (psrepl/send-to-powershell (list (concat ". \"" filename "\""))))))
```

This function first gets the full path of the current file using `buffer-file-name` function. If the file name is not `nil`, it calls `psrepl/send-to-powershell` with a list containing the full path of the file enclosed in `.` operator.

You can bind this function to a keybinding in your Emacs configuration file like this:

```elisp
(global-set-key (kbd "C-c C-o") #'psrepl/open-current-file)
```

This binds the `psrepl/open-current-file` function to the `C-c C-o` keybinding, so you can use it to quickly open the current file in the PowerShell REPL.

[ME]: Thanks!

[AI]: You're welcome! Let me know if you need any other help.

#+end_src

** Putting it all together
Ok, so it looks like we got a pretty solid start for a script here minor plugin here. Putting it all together,

#+begin_src elisp
(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (cmd (format "powershell.exe -File \"%s\" %s" script
                      (mapconcat 'identity args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))

(defun my/eval-region-to-powershell (orig-fun &rest args)
  "Advice function to modify behavior of `eval/send-region-to-repl'.

   This function intercepts the call to `eval/send-region-to-repl' and
   modifies its behavior to send the lines as a list of strings to the
   function `psrepl/send-to-powershell' only when the major mode is
   `powershell-mode'. Otherwise, it delegates to the original function."
  (if (eq major-mode 'powershell-mode)
      (let ((region-str (buffer-substring-no-properties
                         (region-beginning) (region-end))))
        (psrepl/send-to-powershell (split-string region-str "\n")))
    (apply orig-fun args)))

(defun psrepl/set-breakpoint (linenum filename)
  "Sets a breakpoint at LINENUM in FILENAME using `Set-PSBreakpoint` cmdlet."
  (psrepl/send-to-powershell
   (list (format "Set-PSBreakpoint -Line %d -Script \"%s\"" linenum filename))))

(defun psrepl/set-breakpoint-here ()
  "Sets a breakpoint at the current cursor position in the current buffer using `Set-PSBreakpoint` cmdlet."
  (interactive)
  (let ((linenum (line-number-at-pos))
        (filename (buffer-file-name)))
    (when filename
      (psrepl/set-breakpoint linenum filename))))

(defun psrepl/open-current-file ()
  "Opens the current file in the PowerShell REPL using `.` operator."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (psrepl/send-to-powershell (list (concat ". \"" filename "\""))))))

(global-set-key (kbd "C-c C-o") #'psrepl/open-current-file)
(global-set-key (kbd "C-c C-b") #'psrepl/set-breakpoint-here)
#+end_src
* Second iteration.
Now, there are some obvious errors in the powershell script and, honestly, I dont really know elisp at all. So next up, before trying to wrap my head agains the elisp debugger. I think we should ask ChatGPT to review its code.#

** Powershell Review
#+begin_ai
[SYS]: You are a senior powershell developer

[ME]: Hi! Please review the following code bellow, give a detailed explenation for each part and comment any bugs or incorrect parts.
```powershell
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = "powershell.exe"
        $psi.RedirectStandardInput = $true
        $psi.UseShellExecute = $false
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        $strings = $StringsToSend[0].Split(" ")
        foreach ($string in $strings) {
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($string)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}
```

[AI]: This function is named `Send-StringsToProcess` and it sends an array of strings to a specified process ID's standard input channel.

- `[CmdletBinding()]` specifies that the function is a cmdlet and can accept common parameters.
- The function accepts two parameters:

  - `$StringsToSend` is an array of strings that are sent to the process.
  - `$ProcessId` is the ID of the process that will receive the strings.

- `Begin` block creates a new process start info object and sets properties:

  - `$psi.FileName` specifies the name of the executable file that will be run when opening the process.
  - `$psi.RedirectStandardInput` sets it to true so that input comes from the StandardInput stream.
  - `$psi.UseShellExecute` is set to false, meaning that the command will be executed through the Win32 API, without the use of a shell.

- `$process` is set to the process with the `$ProcessId`, retrieved using the `GetProcessById` method from the `System.Diagnostics.Process` class.

- `Process` block splits the first element of `$StringsToSend` into an array of strings, then iterates through each string in the array and sends it to the process's standard input channel using `WriteLine` method.

- `End` block is responsible for closing and disposing of the standard input channel.

There are no major issues with the code, however, `$StringsToSend[0]` may not be what was intended, as it only sends the first element of the input string array. Also, it might be useful to add some error handling if the process cannot be found by the specified ID or if the standard input channel cannot be accessed.

[ME]: 
#+end_ai

Ok. I expected it to give some comment about the entierly redundant =$psi= variable. Thats not super encouraging. It is correct about that weired indexing, but its not super useful.

** Elisp Review
Lets ask for a review of the elisp module we produced

#+begin_ai
[SYS]: You are an expert elisp developer

[ME]: Hi. Explain the following elisp code line by line and point out any errors.
```elisp

(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (cmd (format "powershell.exe -File \"%s\" %s" script
                      (mapconcat 'identity args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))

(defun my/eval-region-to-powershell (orig-fun &rest args)
  "Advice function to modify behavior of `eval/send-region-to-repl'.

   This function intercepts the call to `eval/send-region-to-repl' and
   modifies its behavior to send the lines as a list of strings to the
   function `psrepl/send-to-powershell' only when the major mode is
   `powershell-mode'. Otherwise, it delegates to the original function."
  (if (eq major-mode 'powershell-mode)
      (let ((region-str (buffer-substring-no-properties
                         (region-beginning) (region-end))))
        (psrepl/send-to-powershell (split-string region-str "\n")))
    (apply orig-fun args)))

(defun psrepl/set-breakpoint (linenum filename)
  "Sets a breakpoint at LINENUM in FILENAME using `Set-PSBreakpoint` cmdlet."
  (psrepl/send-to-powershell
   (list (format "Set-PSBreakpoint -Line %d -Script \"%s\"" linenum filename))))

(defun psrepl/set-breakpoint-here ()
  "Sets a breakpoint at the current cursor position in the current buffer using `Set-PSBreakpoint` cmdlet."
  (interactive)
  (let ((linenum (line-number-at-pos))
        (filename (buffer-file-name)))
    (when filename
      (psrepl/set-breakpoint linenum filename))))

(defun psrepl/open-current-file ()
  "Opens the current file in the PowerShell REPL using `.` operator."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (psrepl/send-to-powershell (list (concat ". \"" filename "\""))))))

(global-set-key (kbd "C-c C-o") #'psrepl/open-current-file)
(global-set-key (kbd "C-c C-b") #'psrepl/set-breakpoint-here)
```

[AI]: The code defines a few functions and sets keybindings to invoke them. Here's my line by line explanation, along with any errors I find:

```elisp
(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (cmd (format "powershell.exe -File \"%s\" %s" script
                      (mapconcat 'identity args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))
```
This function invokes a PowerShell script asynchronously. It takes `args` as an argument, which should be a list of strings. The script is hardcoded as `"path/to/WriteToPsRepl.ps1"`. The `format` function is used to construct the actual command that will be executed. It first sets `script` and then uses it to interpolate a call to `powershell.exe`, and the `mapconcat` function is used to join together the `args` list with spaces between them. The `async-start-process` function starts a new asynchronous process with the given command.

I don't see any errors in this function.

```elisp
(defun my/eval-region-to-powershell (orig-fun &rest args)
  "Advice function to modify behavior of `eval/send-region-to-repl'.

   This function intercepts the call to `eval/send-region-to-repl' and
   modifies its behavior to send the lines as a list of strings to the
   function `psrepl/send-to-powershell' only when the major mode is
   `powershell-mode'. Otherwise, it delegates to the original function."
  (if (eq major-mode 'powershell-mode)
      (let ((region-str (buffer-substring-no-properties
                         (region-beginning) (region-end))))
        (psrepl/send-to-powershell (split-string region-str "\n")))
    (apply orig-fun args)))
```

This function is defined as an advice function for `eval/send-region-to-repl`. It takes `orig-fun` and `args` as arguments. The function checks the major mode and only sends the region to the PowerShell repl if the major mode is `powershell-mode`. It does this by using `buffer-substring-no-properties` to get the text in the region, splitting it into lines with `split-string`, and then passing the resulting list of strings to `psrepl/send-to-powershell`. If the major mode is not `powershell-mode`, it delegates to the original function with `apply`.

I don't see any errors in this function.

```elisp
(defun psrepl/set-breakpoint (linenum filename)
  "Sets a breakpoint at LINENUM in FILENAME using `Set-PSBreakpoint` cmdlet."
  (psrepl/send-to-powershell
   (list (format "Set-PSBreakpoint -Line %d -Script \"%s\"" linenum filename))))
```

This function sets a breakpoint at the specified `linenum` in the given `filename`. It calls `format` to construct a command that can set the desired breakpoint using `Set-PSBreakpoint`. It sends the constructed command to `psrepl/send-to-powershell` as a list of strings.

I don't see any errors in this function.

```elisp
(defun psrepl/set-breakpoint-here ()
  "Sets a breakpoint at the current cursor position in the current buffer using `Set-PSBreakpoint` cmdlet."
  (interactive)
  (let ((linenum (line-number-at-pos))
        (filename (buffer-file-name)))
    (when filename
      (psrepl/set-breakpoint linenum filename))))
```

This function sets a breakpoint at the current cursor position in the current buffer by calling the `psrepl/set-breakpoint` function defined above. It does this by getting the current line number with `line-number-at-pos`, getting the current file name with `buffer-file-name`, and then calling `psrepl/set-breakpoint` with the obtained `linenum` and `filename`. It only calls `psrepl/set-breakpoint` if `filename` is non-nil.

I don't see any errors in this function.

```elisp
(defun psrepl/open-current-file ()
  "Opens the current file in the PowerShell REPL using `.` operator."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (psrepl/send-to-powershell (list (concat ". \"" filename "\""))))))
```

This function opens the current file in the PowerShell REPL using the `.` operator. It does this by calling `psrepl/send-to-powershell` with a command that concatenates `"."` with `filename` in quotes as a list of strings. It only calls `psrepl/send-to-powershell` if `filename` is non-nil.

I don't see any errors in this function.

```elisp
(global-set-key (kbd "C-c C-o") #'psrepl/open-current-file)
(global-set-key (kbd "C-c C-b") #'psrepl/set-breakpoint-here)
```

These lines bind the functions defined above to the key sequences `C-c C-o` and `C-c C-b`, respectively.

I don't see any errors in these lines.

[ME]: 
#+end_ai

The only things that stands out here is that any quotation marks  in the lines sent to powershell will break the formatting in the elisp function. This should be solvable using some encoding scheme.

#+begin_ai
[SYS]: You are an expert software developer

[ME]: Hi, how much does the size increase when you encode a string usign base64 encoding?

[AI]: When you encode a string using base64 encoding, the resulting encoded string size will be approximately 33% larger than the original string size. This happens because base64 encoding converts every 3 bytes of input data into 4 bytes of output data. So, the encoded string will have more characters than the original string, but it will contain the same information. For instance, if the original string has 100 bytes, the base64-encoded string will be approximately 133 bytes.

[ME]: 
#+end_ai

Sounds acceptable

#+begin_ai
[SYS]: You are an expert software developer

[ME]: Rewrite the following elisp function psrepl/send-to-powershell. It should encode the strings using base64 encodings before sending them to the powershell script
```elisp
(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (cmd (format "powershell.exe -File \"%s\" %s" script
                      (mapconcat 'identity args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))
```

[ME]:

[AI]: Here's the rewritten function that encodes the arguments using base64 before sending them to the PowerShell script:

```elisp
(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments.
   Arguments are encoded using base64."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (encoded-args (mapcar (lambda (arg) (base64-encode-string arg 't)) args))
         (cmd (format "powershell.exe -ExecutionPolicy Bypass -EncodedCommand %s"
                      (base64-encode-string (concat ". \"%s\" %s" script (mapconcat 'identity encoded-args " ")))))
    (async-start-process "powershell" "powershell" nil cmd)))
```
The changes I made are:
- Added a new variable `encoded-args` which is a list containing the base64-encoded versions of the original arguments.
- Updated the `cmd` variable to include the `-EncodedCommand` switch instead of passing the arguments as plain text. The value of `-EncodedCommand` is a base64-encoded command that PowerShell can execute.
- The base64-encoded command is created by concatenating the script path, the `encoded-args` list (joined with spaces), and wrapping the whole thing in quotes. This string is then passed to the `base64-encode-string` function.
- I also added the `-ExecutionPolicy Bypass` option to bypass the execution policy in PowerShell to make sure the script is allowed to run.

[ME]: Hu, dont use the -EncodedCommand flag, just pass the encoded strings as normal arguments

[AI]: Sure, here's the updated function that encodes the arguments using base64 and passes them as individual arguments to the PowerShell script:

```elisp
(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments.
   Arguments are encoded using base64."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (encoded-args (mapcar (lambda (arg) (base64-encode-string arg 't)) args))
         (cmd (concat "powershell.exe -ExecutionPolicy Bypass -File "
                      script " " (mapconcat 'identity encoded-args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))
```

The changes I made are:

- Removed the use of `-EncodedCommand` switch and instead pass the encoded arguments as normal arguments to the Powershell script. 
- Updated the `cmd` variable to include the encoded arguments as separate arguments to the script instead of concatenating them in a single string using `format` function. 
- Passed the `-ExecutionPolicy Bypass` option to bypass the execution policy in PowerShell.

[ME]: Ok, thats great, just a final change. The path to the script is ".\WriteToPsRepl.ps1" and as the first argument it should take an int called PID which can be picked up from psrepl/pid


[AI]: Sure, here's the updated function that includes the changes you requested:

```elisp
(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments.
   Arguments are encoded using base64."
  (let* ((script ".\\WriteToPsRepl.ps1")
         (pid (format "%d" psrepl/pid))
         (encoded-args (mapcar (lambda (arg) (base64-encode-string arg 't)) args))
         (cmd (concat "powershell.exe -ExecutionPolicy Bypass -File "
                      script " " pid " " (mapconcat 'identity encoded-args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))
```

The changes I made are:

- Updated the `script` variable to include the correct path to the PowerShell script.
- Added a new variable `pid` that stores the value of `psrepl/pid` as a string.
- Updated the `cmd` variable to include the `pid` variable as the first argument to the PowerShell script.
- Passed the `-ExecutionPolicy Bypass` option to bypass the execution policy in PowerShell.

[ME]: 
#+end_ai


#+begin_ai

[SYS]: You are an elite software developer

[ME]: How do I write a powershell script which can be used as a command and pick up commandline arguments, i.e. How would i write the script "script.ps1" so that I can run it using `powershell.exe script.ps1 "Argument 1" "Argument 2"` and it should be able to take any number of arguments



[AI]: To create a PowerShell script that accepts command-line arguments, you can use the special variable `$args`. This variable contains an array of all the arguments passed to the script.

Here is an example script that prints out all the arguments:

```powershell
# script.ps1

foreach ($arg in $args) {
    Write-Output $arg
}
```

You can run this script in PowerShell by passing in any number of arguments:

```
powershell.exe script.ps1 "Argument 1" "Argument 2" "Argument 3"
```

This will output:

```
Argument 1
Argument 2
Argument 3
```

You can then modify the script to perform whatever actions you want with the arguments passed in.

[ME]: Ok cool
Now modify the following script so that it uses any number of parameters passed from the command line, i.e. "powershell.exe WriteToPSRepl.ps1 arg1 arg2 arg2" further. also, this time the arguments will be base64 encoded and needs to be decoded again before being passed to the console.
WriteToPSRepl.ps1
```powershell
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = "powershell.exe"
        $psi.RedirectStandardInput = $true
        $psi.UseShellExecute = $false
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        $strings = $StringsToSend[0].Split(" ")
        foreach ($string in $strings) {
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($string)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}
```

[AI]: Sure, here's a modified version of the `WriteToPSRepl.ps1` script that decodes the base64-encoded arguments and sends them to a PowerShell process:

```powershell
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = "powershell.exe"
        $psi.RedirectStandardInput = $true
        $psi.UseShellExecute = $false
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        foreach ($stringToSend in $StringsToSend) {
            $decodedString = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($stringToSend))
            $strings = $decodedString.Split(" ")
            foreach ($string in $strings) {
                $processStdIn = $process.StandardInput
                $processStdIn.WriteLine($string)
            }
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}

$arguments = [System.Environment]::GetCommandLineArgs()
$arguments = $arguments[1..($arguments.Length - 1)]
Send-StringsToProcess -StringsToSend $arguments -ProcessId $pid
```

This modified version reads the command-line arguments using `[System.Environment]::GetCommandLineArgs()`, excluding the script name by indexing the array with `[1..($arguments.Length - 1)]`. This array of arguments is then passed to the `Send-StringsToProcess` function.

Inside the `Send-StringsToProcess` function, each encoded string is first decoded using the `FromBase64String` method of the `System.Convert` class. The decoded string is then split into an array of space-separated strings and sent to the PowerShell process using the `WriteLine` method of the `StandardInput` property.

[ME]: Thanks! But it seems to me that the $psi variable is useless, why is it included? Also, there is no need to split the decoded string. I want it written in full to the console.

[AI]: You're correct that the `$psi` variable isn't necessary in this case because we're using the default `powershell.exe` executable. The original script may have included it for the sake of completeness.

Regarding splitting the decoded string, you're right that it's unnecessary if you want to send the entire decoded string to the console. Here's the modified `Send-StringsToProcess` function that does not split the decoded string:

```powershell
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        foreach ($stringToSend in $StringsToSend) {
            $decodedString = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($stringToSend))
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($decodedString)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}
```

This modified version simply sends the decoded string as a whole to the PowerShell process using `WriteLine`.

[ME]: 
#+end_ai

#+begin_src powershell :tangle WriteToPsRepl.ps1
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        foreach ($stringToSend in $StringsToSend) {
            $decodedString = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($stringToSend))
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($decodedString)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}

$arguments = [System.Environment]::GetCommandLineArgs()
$arguments = $arguments[1..($arguments.Length - 1)]
Send-StringsToProcess -StringsToSend $arguments -ProcessId $pid
#+end_src


#+begin_src elisp :tangle psrepl.el
(defun psrepl/set-pid (pid)
  "Set PID as the psrepl process ID."
  (setq psrepl/pid))

(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments.
   Arguments are encoded using base64."
  (let* ((script ".\\WriteToPsRepl.ps1")
         (pid (format "%d" psrepl/pid))
         (encoded-args (mapcar (lambda (arg) (base64-encode-string arg 't)) args))
         (cmd (concat "powershell.exe -ExecutionPolicy Bypass -File "
                      script " " pid " " (mapconcat 'identity encoded-args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))

(defun psrepl/eval-region-to-powershell (orig-fun &rest args)
  "Advice function to modify behavior of `eval/send-region-to-repl'.

   This function intercepts the call to `eval/send-region-to-repl' and
   modifies its behavior to send the lines as a list of strings to the
   function `psrepl/send-to-powershell' only when the major mode is
   `powershell-mode'. Otherwise, it delegates to the original function."
  (if (eq major-mode 'powershell-mode)
      (let ((region-str (buffer-substring-no-properties
                         (region-beginning) (region-end))))
        (psrepl/send-to-powershell (split-string region-str "\n")))
    (apply orig-fun args)))

(defun psrepl/set-breakpoint (linenum filename)
  "Sets a breakpoint at LINENUM in FILENAME using `Set-PSBreakpoint` cmdlet."
  (psrepl/send-to-powershell
   (list (format "Set-PSBreakpoint -Line %d -Script \"%s\"" linenum filename))))

(defun psrepl/set-breakpoint-here ()
  "Sets a breakpoint at the current cursor position in the current buffer using `Set-PSBreakpoint` cmdlet."
  (interactive)
  (let ((linenum (line-number-at-pos))
        (filename (buffer-file-name)))
    (when filename
      (psrepl/set-breakpoint linenum filename))))

(defun psrepl/open-current-file ()
  "Opens the current file in the PowerShell REPL using `.` operator."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (psrepl/send-to-powershell (list (concat ". \"" filename "\""))))))

(global-set-key (kbd "C-c C-o") #'psrepl/open-current-file)
(global-set-key (kbd "C-c C-b") #'psrepl/set-breakpoint-here)
(advice-add 'eval/send-region-to-repl :around #'psrepl/eval-region-to-powershell)
#+end_src
