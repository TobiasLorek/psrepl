#+title: An Powershell Repl for Emacs using the Windows terminal

The aim of this project is to setup functionality to let emacs interact with powershell running in Windows Terminal.
1. [ ] Send input to a running Windows Terminal with an powershell shell.
2. [ ] Use `eval/send-reigon-to-repl` to send text to a WT Powershell repl
3. [ ] Set breakpoints in the WT PS Repl using the current location in the file
4. [ ] Import the file into the WT PS Repl

 The Non-Goals of this project are:
5. To write  a pure elisp plugin.
6. To be completely self contained. It is ok if some manual tweaking is required every time you run it.

* First Iteration
** Sending lines to a running powershell process in windows terminal
I am hoping this is possible using powershell, so lets ask the AI to write it for us.

*** First Attempt, Writing to the Stdin of the process  = Complete shit
Ok, so the first powershell script looks sort of legit. But it just didn't work cause it did not support the use case I was going for. I've copied it bellow for reference.

#+begin_src markdown
[SYS]: You are a powershell developer

[ME]: Hi. Write a powershell function that writes an array of strings to the console of an other running powershell instance. The function should take an array of strings and an integer with the PID to the other powershell process as input. It should aquire the stdin handle to the powershell process and post the strings in the array one by one. Then it should release the stdin handle and detach from the process.

[AI]: Sure, here's an example function that should do what you're asking for:

```
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true)]
        [int]$ProcessId
    )

    Begin {
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = "powershell.exe"
        $psi.RedirectStandardInput = $true
        $psi.UseShellExecute = $false
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        foreach ($string in $StringsToSend) {
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($string)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}
```

Here's how you can use the function:

1. Get the process Id of the other PowerShell process that you want to send the strings to. You can do this by opening Task Manager, right-clicking on the PowerShell process, and selecting "Go to details". The process Id is listed under the "Details" tab.

2. Open a PowerShell console and call the `Send-StringsToProcess` function with the array of strings you want to send and the process Id of the other PowerShell process:

```
$strings = @("String 1", "String 2", "String 3")
Send-StringsToProcess -StringsToSend $strings -ProcessId <other PowerShell process Id>
```

This should write each string in the array to the other PowerShell process's console window one by one.

Note that the other PowerShell process must be running as an interactive console application for this to work. If it's running in a non-interactive mode, such as from a scheduled task or Windows service, it won't have a stdin handle that can be written to.

[ME]: Thanks!

[AI]: You're welcome! Let me know if you have any other PowerShell questions or needs.

[ME]: Oh, and the script should be able to pick up the strings as command line arguments

[AI]: Sure, no problem. Here is an updated version of the `Send-StringsToProcess` function that can accept strings as command line arguments:

```
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = "powershell.exe"
        $psi.RedirectStandardInput = $true
        $psi.UseShellExecute = $false
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        $strings = $StringsToSend[0].Split(" ")
        foreach ($string in $strings) {
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($string)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}
```

This updated function accepts input from the pipeline and splits the strings on white space to generate an array of strings that you can use to send to the other PowerShell process. Here is an example of how you can use the updated function:

`"Hello World" | Send-StringsToProcess -ProcessId <other PowerShell process Id>`

This example sends the string "Hello World" to the other PowerShell process.

You can also use the `-StringsToSend` parameter as before:

```
Send-StringsToProcess -StringsToSend "Hello World" -ProcessId <other PowerShell process Id>
```

This example also sends the string "Hello World" to the other PowerShell process.

Note that the same caveat applies as before regarding the other PowerShell process needing to be running as an interactive console application.

#+end_src

Well that does look promising but I think it will require some tweaking to get it working.

#+begin_src powershell
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = "powershell.exe"
        $psi.RedirectStandardInput = $true
        $psi.UseShellExecute = $false
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        $strings = $StringsToSend[0].Split(" ")
        foreach ($string in $strings) {
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($string)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}
#+end_src
*** Second Attempt.
Ok, I wasted a lot of time on the first attempt. So rather than just one way this time I will try to different approaches simultaneously
**** First Idea; Use the console api to send data to the console.
Lets give it a try:
#+begin_ai
[SYS]: You are an expert windows developer.

[ME]: Write a powershell wich uses the Console API in kernel32.dll to attach to a running console and write an array of lines into its stdin.
After its finished it should detach and free the console again.

[AI]: Sure, here's an example PowerShell script that does what you're asking for:

```powershell
# Load the kernel32.dll library
Add-Type -Name ConsoleAPI -Namespace Kernel32 -MemberDefinition @"
[DllImport("kernel32.dll")]
public static extern bool AttachConsole(uint dwProcessId);
[DllImport("kernel32.dll")]
public static extern bool FreeConsole();
[DllImport("kernel32.dll")]
public static extern bool SetConsoleCtrlHandler(IntPtr handlerRoutine, bool add);
[DllImport("kernel32.dll")]
public static extern bool WriteConsoleInput(IntPtr hConsoleInput, INPUT_RECORD[] lpBuffer, uint nLength, out uint lpNumberOfEventsWritten);
public struct INPUT_RECORD {
    public ushort EventType;
    public KEY_EVENT_RECORD KeyEvent;
}
public struct KEY_EVENT_RECORD {
    public bool bKeyDown;
    public ushort wRepeatCount;
    public ushort wVirtualKeyCode;
    public ushort wVirtualScanCode;
    public char UnicodeChar;
    public uint dwControlKeyState;
}
"@

# Attach to an existing console
if (![Kernel32.ConsoleAPI]::AttachConsole(-1)) {
    Write-Error "Failed to attach to console."
    exit
}

# Create an array of lines to write to stdin
$lines = @("Hello, world!", "How are you?", "Goodbye.")

# Convert the lines to INPUT_RECORD structures
$records = @()
foreach ($line in $lines) {
    $chars = [char[]]$line
    foreach ($char in $chars) {
        $record = New-Object Kernel32.INPUT_RECORD
        $record.EventType = 1 # KEY_EVENT
        $record.KeyEvent.bKeyDown = $true
        $record.KeyEvent.UnicodeChar = $char
        $records += $record

        $record = New-Object Kernel32.INPUT_RECORD
        $record.EventType = 1 # KEY_EVENT
        $record.KeyEvent.bKeyDown = $false
        $record.KeyEvent.UnicodeChar = $char
        $records += $record
    }
    $record = New-Object Kernel32.INPUT_RECORD
    $record.EventType = 1 # KEY_EVENT
    $record.KeyEvent.bKeyDown = $true
    $record.KeyEvent.wVirtualKeyCode = 13 # Enter
    $records += $record

    $record = New-Object Kernel32.INPUT_RECORD
    $record.EventType = 1 # KEY_EVENT
    $record.KeyEvent.bKeyDown = $false
    $record.KeyEvent.wVirtualKeyCode = 13 # Enter
    $records += $record
}

# Write the INPUT_RECORD structures to stdin
$numWritten = 0
if (![Kernel32.ConsoleAPI]::WriteConsoleInput([System.IntPtr]::Zero, $records, $records.Length, [ref]$numWritten)) {
    Write-Error "Failed to write to console input."
}

# Detach from the console and free resources
[Kernel32.ConsoleAPI]::FreeConsole()
```

This script first loads the kernel32.dll library into PowerShell and defines a structure for the `INPUT_RECORD` and `KEY_EVENT_RECORD` types. It then attaches to an existing console using the `AttachConsole` API function, creates an array of lines to write to stdin, and converts them to `INPUT_RECORD` structures using the `KEY_EVENT_RECORD` info. Finally, it writes the structures to stdin using the `WriteConsoleInput` API function and detaches from the console using the `FreeConsole` API function.

[ME]:
#+end_ai

Ok, thats not super impressive. There is a lot of errors there. Lets give it an other try and ask it to explain it self.

#+begin_ai
[SYS]: You are an expert windows developer.

[ME]: Write a powershell wich uses the Console API in kernel32.dll to attach to a running console and write an array of lines into its stdin.
The script should take a process id, called PID, and an array of strings as arguments
After its finished it should detach and free the console again.
Please comment every line and explain why it is needed.


[AI]: Sure, here's a PowerShell script that uses the Console API in kernel32.dll to attach to a running console and write an array of lines into its stdin:

```powershell
# Load the Console API from kernel32.dll
Add-Type -Name ConsoleApi -Namespace Win32 -MemberDefinition "
[DllImport(\"kernel32.dll\")]
public static extern bool AttachConsole(int dwProcessId);
[DllImport(\"kernel32.dll\", SetLastError = true, CharSet = CharSet.Auto)]
public static extern IntPtr GetStdHandle(int nStdHandle);
[DllImport(\"kernel32.dll\", SetLastError = true)]
public static extern bool WriteConsole(IntPtr hConsoleOutput, string lpBuffer, uint nNumberOfCharsToWrite, out uint lpNumberOfCharsWritten, IntPtr lpReserved);
[DllImport(\"kernel32.dll\", SetLastError = true)]
public static extern bool FreeConsole();
"

# Get the process id and array of strings from the command line arguments
$pid = [int]$args[0]
$lines = $args[1..$($args.Count-1)]

# Attach to the console of the specified process
$consoleAttached = [Win32.ConsoleApi]::AttachConsole($pid)

if ($consoleAttached) {
    try {
        # Get the handle for the console's standard input
        $hStdIn = [Win32.ConsoleApi]::GetStdHandle(-10) # -10 = STD_INPUT_HANDLE

        if ($hStdIn -ne [System.IntPtr]::Zero) {
            # Write each line to the console's standard input
            foreach ($line in $lines) {
                [uint]$written = 0
                [Win32.ConsoleApi]::WriteConsole($hStdIn, $line, $line.Length, [ref]$written, [System.IntPtr]::Zero)
            }
        }
    } finally {
        # Detach from the console and free the console resources
        [void][Win32.ConsoleApi]::FreeConsole()
    }
} else {
    Write-Error "Failed to attach to console for process with id $pid"
}
```

Here's an explanation of what each line does:

- `Add-Type -Name ConsoleApi -Namespace Win32 -MemberDefinition "..."`: Loads the Console API from kernel32.dll into a new .NET type called `ConsoleApi` in the `Win32` namespace.
- `$pid = [int]$args[0]`: Gets the process id from the first command line argument and casts it to an integer.
- `$lines = $args[1..$($args.Count-1)]`: Gets an array of strings from the remaining command line arguments.
- `$consoleAttached = [Win32.ConsoleApi]::AttachConsole($pid)`: Attaches to the console of the specified process using the `AttachConsole` function from the Console API.
- `if ($consoleAttached) { ... }`: Checks if the console was successfully attached before proceeding.
- `$hStdIn = [Win32.ConsoleApi]::GetStdHandle(-10)`: Gets the handle for the console's standard input using the `GetStdHandle` function from the Console API and passing in the constant value `-10` to indicate the standard input handle.
- `if ($hStdIn -ne [System.IntPtr]::Zero) { ... }`: Checks if the standard input handle was successfully obtained before proceeding.
- `foreach ($line in $lines) { ... }`: Loops through each line of input and writes it to the console's standard input using the `WriteConsole` function from the Console API.
- `[void][Win32.ConsoleApi]::FreeConsole()`: Detaches from the console and frees the console resources using the `FreeConsole` function from the Console API.
- `Write-Error "Failed to attach to console for process with id $pid"`: Displays an error message if attaching to the console fails.

[ME]: 
#+end_ai

#+begin_src csharp :tangle WriteToConsole.ps1
# Load the Console API from kernel32.dll
Add-Type -Name ConsoleApi -Namespace Win32 -MemberDefinition "
[DllImport(\"kernel32.dll\")]
public static extern bool AttachConsole(int dwProcessId);
[DllImport(\"kernel32.dll\", SetLastError = true, CharSet = CharSet.Auto)]
public static extern IntPtr GetStdHandle(int nStdHandle);
[DllImport(\"kernel32.dll\", SetLastError = true)]
public static extern bool WriteConsole(IntPtr hConsoleOutput, string lpBuffer, uint nNumberOfCharsToWrite, out uint lpNumberOfCharsWritten, IntPtr lpReserved);
[DllImport(\"kernel32.dll\", SetLastError = true)]
public static extern bool FreeConsole();
"

# Get the process id and array of strings from the command line arguments
$pid = [int]$args[0]
$lines = $args[1..$($args.Count-1)]

# Attach to the console of the specified process
$consoleAttached = [Win32.ConsoleApi]::AttachConsole($pid)

if ($consoleAttached) {
    try {
        # Get the handle for the console's standard input
        $hStdIn = [Win32.ConsoleApi]::GetStdHandle(-10) # -10 = STD_INPUT_HANDLE

        if ($hStdIn -ne [System.IntPtr]::Zero) {
            # Write each line to the console's standard input
            foreach ($line in $lines) {
                [uint]$written = 0
                [Win32.ConsoleApi]::WriteConsole($hStdIn, $line, $line.Length, [ref]$written, [System.IntPtr]::Zero)
            }
        }
    } finally {
        # Detach from the console and free the console resources
        [void][Win32.ConsoleApi]::FreeConsole()
    }
} else {
    Write-Error "Failed to attach to console for process with id $pid"
}
#+end_src

Hum, Well that might be something! I don't really know since I'm writing this on my own computer running linux and testing...

**** Second Idea; Use clipboard to pass data between applications
Ok, an other idea, have Powershell  bring a window into the foreground and tell send the Ctrl+V keys to it.
#+begin_ai
[SYS]: You are a powershell developer

[ME]: Write me powershell function which sends the Ctrl+V keys to a particular window in Microsoft Windows, the window should be identifed by a handler which has been passed as an argument to the function.
Comment every line and explain what it does.

[AI]: Sure, here's a PowerShell function that sends the Ctrl+V keys to a particular window identified by its handler:

```
function Send-CtrlVKeysToWindow([IntPtr]$handle)
{
    # Get the process ID associated with the window handle
    $processID = (Get-Process -Id $handle.ToInt32()).Id

    # Get the target process by ID
    $process = [System.Diagnostics.Process]::GetProcessById($processID)

    # Get the handle of the target window
    $targetWindow = $process.MainWindowHandle

    # Set the target window to be the active window
    [System.Windows.Forms.SendKeys]::SendWait('%')
    [System.Windows.Forms.SendKeys]::SendWait('#')
    [System.Windows.Forms.SendKeys]::SendWait('{' + $targetWindow + '}')
    Start-Sleep -Milliseconds 100

    # Send the Ctrl+V keystrokes to the target window
    [System.Windows.Forms.SendKeys]::SendWait('^v')
}
```

Let me explain what each line does:

```
function Send-CtrlVKeysToWindow([IntPtr]$handle)
```
This declares a function called `Send-CtrlVKeysToWindow` that takes an `IntPtr` handle as an argument.

```
$processID = (Get-Process -Id $handle.ToInt32()).Id
```
This gets the process ID associated with the window handle that was passed in as an argument.

```
$process = [System.Diagnostics.Process]::GetProcessById($processID)
```
This gets the target process for the window by ID.

```
$targetWindow = $process.MainWindowHandle
```
This gets the handle of the target window.

```
[System.Windows.Forms.SendKeys]::SendWait('%')
[System.Windows.Forms.SendKeys]::SendWait('#')
[System.Windows.Forms.SendKeys]::SendWait('{' + $targetWindow + '}')
Start-Sleep -Milliseconds 100
```
These lines set the target window to be the active window. The `SendWait` method of the `SendKeys` class is used to simulate key presses. `%` simulates the Alt key, and `#` simulates the Windows key. By sending `%#{"$targetWindow"}`, we're telling Windows to activate the window with the corresponding handle. The `Start-Sleep` command is included to allow time for the window to be activated.

```
[System.Windows.Forms.SendKeys]::SendWait('^v')
```
This sends the Ctrl+V keystrokes to the target window, which simulates pasting from the clipboard.

Hope this helps!

[ME]: Thats cool. But if possible I would like the window to remain in the background

[AI]: Sure, I modified the previous code to send the Ctrl+V keys to the target window without activating it. Here's the updated code:

```powershell
function Send-CtrlVKeysToWindow([IntPtr]$handle)
{
    # Get the process ID associated with the window handle
    $processID = (Get-Process -Id $handle.ToInt32()).Id

    # Get the target process by ID
    $process = [System.Diagnostics.Process]::GetProcessById($processID)

    # Get the handle of the target window
    $targetWindow = $process.MainWindowHandle

    # Simulate a key down event for the Ctrl key
    [System.Windows.Forms.SendKeys]::SendWait('{CTRLDOWN}')

    # Simulate a key down event for the V key
    [System.Windows.Forms.SendKeys]::SendWait('v')

    # Simulate a key up event for the V key
    [System.Windows.Forms.SendKeys]::SendWait('{CTRLUP}')
}
```

Let me explain the key changes:
```
[System.Windows.Forms.SendKeys]::SendWait('{CTRLDOWN}')
```
This line simulates a key down event for the Ctrl key.

```
[System.Windows.Forms.SendKeys]::SendWait('v')
```
This line simulates a key press for the "V" key.

```
[System.Windows.Forms.SendKeys]::SendWait('{CTRLUP}')
```
This line simulates a key up event for the Ctrl key.

By simulating a down event for the Ctrl key and then simulating the "V" key press and finally simulating the up event for the Ctrl key, the function simulates the Ctrl+V keystroke combination, resulting in a paste operation.

Since no window activation is performed, the target window will remain in the background. I hope this helps.

[ME]: But then the keys wont be sent that that window, will they? Is it possible to send keys to a window while it remains in the background?

[AI]: You are correct, if the window is in the background, the keys may not be sent to it as the operating system won't route the input to a non-activated window.

To send keystrokes to a window in the background, we can use the `SendMessage` function from the Windows API to send a keystroke message to the target window.

Here's the modified code that will send Ctrl+V keystrokes to a window identified by its handler while keeping it in the background:

```powershell
Add-Type -TypeDefinition @"
    using System;
    using System.Runtime.InteropServices;
    public class PInvokeHelper {
        [DllImport("user32.dll")]
        public static extern bool SendMessage(IntPtr hWnd, uint Msg, int wParam, int lParam);
    }
"@

function Send-CtrlVKeysToWindow([IntPtr]$handle)
{
    # Get the window handle
    $targetWindow = $handle

    # Activate the target window to prepare it to receive the keystroke message
    [PInvokeHelper]::SendMessage($targetWindow, 0x0100, 0x000D, 0)

    # Simulate a key down message for the Ctrl key
    [PInvokeHelper]::SendMessage($targetWindow, 0x0100, 0x0014, 0x001D0001)

    # Simulate a key down message for the V key
    [PInvokeHelper]::SendMessage($targetWindow, 0x0100, 0x0022, 0x002F0001)

    # Simulate a key up message for the V key
    [PInvokeHelper]::SendMessage($targetWindow, 0x0101, 0x0022, 0xC02F0001)

    # Simulate a key up message for the Ctrl key
    [PInvokeHelper]::SendMessage($targetWindow, 0x0101, 0x0014, 0xC01D0001)
}
```

Let me explain what's changed here:

```
Add-Type -TypeDefinition @"
    using System;
    using System.Runtime.InteropServices;
    public class PInvokeHelper {
        [DllImport("user32.dll")]
        public static extern bool SendMessage(IntPtr hWnd, uint Msg, int wParam, int lParam);
    }
"@
```

This code block uses the `Add-Type` cmdlet to compile and load a C# code snippet that defines the `SendMessage` function, which we'll use to send messages to the window.

```
# Get the window handle
$targetWindow = $handle
```

This line gets the handle of the target window, passed in as an argument.

```
[PInvokeHelper]::SendMessage($targetWindow, 0x0100, 0x000D, 0)
```

This line sends a key down message to activate the window, by passing the `WM_KEYDOWN` message (0x0100) with `VK_RETURN` (0x000D) and 0 (lParam) parameters. This prepares the window to receive keystroke messages.

```
[PInvokeHelper]::SendMessage($targetWindow, 0x0100, 0x0014, 0x001D0001)
```

This line sends a key down message for the Ctrl key, by passing the `WM_KEYDOWN` message with `VK_CONTROL` (0x0014) and `EXTENDED` (0x1000000) flags. This informs the window that the Ctrl key is being held down.

```
[PInvokeHelper]::SendMessage($targetWindow, 0x0100, 0x0022, 0x002F0001)
```

This line sends a key down message for the V key, by passing the `WM_KEYDOWN` message with `VK_V` (0x0022) and `EXTENDED` (0x1000000) flags. This simulates the key press.

```
[PInvokeHelper]::SendMessage($targetWindow, 0x0101, 0x0022, 0xC02F0001)
```

This line sends a key up message for the V key, by passing the `WM_KEYUP` message (0x0101) with `VK_V` (0x0022) and the `KEYUP` (0xC0000000) flag. This lets go of the V key.

```
[PInvokeHelper]::SendMessage($targetWindow, 0x0101, 0x0014, 0xC01D0001)
```

This line sends a key up message for the Ctrl key, by passing the `WM_KEYUP` message with `VK_CONTROL` (0x0014) and the `KEYUP` (0xC0000000) flag. This lets go of the Ctrl key.

With this function, you should be able to send keystrokes to a window while keeping it in the background.

[ME]: 
#+end_ai

Hum, well I would be lying if I said i liked it. Lets hope the ConsoleApi  works!

#+begin_src csharp :tangle SendCtrlV.ps1
Add-Type -TypeDefinition @"
    using System;
    using System.Runtime.InteropServices;
    public class PInvokeHelper {
        [DllImport("user32.dll")]
        public static extern bool SendMessage(IntPtr hWnd, uint Msg, int wParam, int lParam);
    }
"@

function Send-CtrlVKeysToWindow([IntPtr]$handle)
{
    # Get the window handle
    $targetWindow = $handle

    # Activate the target window to prepare it to receive the keystroke message
    [PInvokeHelper]::SendMessage($targetWindow, 0x0100, 0x000D, 0)

    # Simulate a key down message for the Ctrl key
    [PInvokeHelper]::SendMessage($targetWindow, 0x0100, 0x0014, 0x001D0001)

    # Simulate a key down message for the V key
    [PInvokeHelper]::SendMessage($targetWindow, 0x0100, 0x0022, 0x002F0001)

    # Simulate a key up message for the V key
    [PInvokeHelper]::SendMessage($targetWindow, 0x0101, 0x0022, 0xC02F0001)

    # Simulate a key up message for the Ctrl key
    [PInvokeHelper]::SendMessage($targetWindow, 0x0101, 0x0014, 0xC01D0001)
}

#+end_src
**** Argument to powershell scrips
Last time i never even got any of the arguments i wanted when running the powershell scripts. Lest see if we can fix that.

#+begin_ai
[SYS]: You are a software developer

[ME]: Hi. Write me a powershell script called `echoAll.ps1` which, when run using "pwsh.exe -File echoAll.ps1 -args 'arg 1 asd' 'arg 2 line' 'arg 4 line'" outputs the lines one after each other. It should accept any number of lines

[AI]: Sure, here's the script `echoAll.ps1` that will output the lines passed as arguments one after another:

```
Param(
  [Parameter(Mandatory=$true, Position=0, ValueFromRemainingArguments=$true)]
  [string[]]$lines
)

foreach($line in $lines){
  Write-Output $line
}
```

This script accepts any number of arguments as input, using the `ValueFromRemainingArguments` option to gather them all into a single parameter named `$lines`. Then, it simply loops through each of the lines and outputs it using the `Write-Output` cmdlet.

You can run the script with the following command:

```
pwsh.exe -File echoAll.ps1 -args 'arg 1 asd' 'arg 2 line' 'arg 4 line'
```

The output will be:

```
arg 1 asd
arg 2 line
arg 4 line
```

[ME]: 
#+end_ai


** Use `eval/send-region-to-repl` to send text to a WT Powershell repl
Ok, next up we need to send it some data. But first I think we need to store the PID somewhere.

#+begin_src markdown
[SYS]: You are an elisp developer

[ME]: Write an elisp function with stores the value if PID in the variable psrepl/pid so that it can be accessible by other functions

[AI]: Here is an elisp function that stores the value of PID in the variable `psrepl/pid`:

```elisp
(defun psrepl/set-pid (pid)
  "Set PID as the psrepl process ID."
  (setq psrepl/pid))
```

This function takes one argument `pid` and sets it as the value of the variable `psrepl/pid`. You can call this function from other functions to store the value of PID, making it easily accessible for other parts of your code.

[ME]: Thanks
#+end_src

Alright. With that taken care we need a function that can call the powershell script, with the PID and send a list of strings to it.

#+begin_src markdown
[SYS]: You are an elisp developer

[ME]: Write me an elisp function which takes a list of strings and invokes the powershell script WriteToPsRepl.ps1 passing the strings as arguments. If possible we should not wait for it to finish

[AI]: Here's an elisp function that takes a list of strings and invokes the `WriteToPsRepl.ps1` PowerShell script passing the strings as arguments without waiting for it to finish:

```elisp
(defun run-ps-script-async (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (cmd (format "powershell.exe -File \"%s\" %s" script
                      (mapconcat 'identity args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))
```

To use this function, simply call it with a list of strings:

```elisp
(run-ps-script-async '("arg1" "arg2" "arg3"))
``` 

This will start the PowerShell process asynchronously and execute the script in the background passing the given arguments.

[ME]: Thanks
#+end_src

Ok, we are making progress! Next up, and this i suspect will be difficult, is to hijack the eval/send-region-to-repl to use our function instead.

#+begin_src markdown
[SYS]: You are an elisp developer

[ME]: I need to change the behavior of the function eval/send-reigon-to-repl so that it send the lines as a list of strings to the function psrepl/send-to-powershell. But only when the major mode is powershell-mode

[AI]: You can modify the behavior of the `eval/send-region-to-repl` function in Emacs Lisp to suit your needs by defining an advice function that intercepts the call to this function and modifies its behavior based on the current major mode.

Here's an example advice function that you can use to achieve the desired behavior:

``` emacs-lisp
(defun my/eval-region-to-powershell (orig-fun &rest args)
  "Advice function to modify behavior of `eval/send-region-to-repl'.

   This function intercepts the call to `eval/send-region-to-repl' and
   modifies its behavior to send the lines as a list of strings to the
   function `psrepl/send-to-powershell' only when the major mode is
   `powershell-mode'. Otherwise, it delegates to the original function."
  (if (eq major-mode 'powershell-mode)
      (let ((region-str (buffer-substring-no-properties
                         (region-beginning) (region-end))))
        (psrepl/send-to-powershell (split-string region-str "\n")))
    (apply orig-fun args)))
```

This advice function checks if the current major mode is `powershell-mode`. If it is, then it retrieves the region text and sends each line as a separate string to the `psrepl/send-to-powershell` function using the `split-string` function to split the region text into a list of lines. Otherwise, it delegates to the original function.

You can use this function by adding the advice to the `eval/send-region-to-repl` function:

``` emacs-lisp
(advice-add 'eval/send-region-to-repl :around #'my/eval-region-to-powershell)
```

This will modify the behavior of the `eval/send-region-to-repl` function to behave as you intended only when the major mode is `powershell-mode`.

[ME]: Thanks!

[AI]: You're welcome! Let me know if you have any further questions or need further assistance.

[ME]: 
#+end_src


Ok, It looks like we are almost there! all in about 30 minutes using ChatGPT

** Working with scripts. Setting breakpoints and inclusing them
Ok, so next up it setting breakpoints and including the script source. This should be fairly straight forward. For the break point we need the current line and the script name. Then we just send the string "Set-PSBreakPoint -Line 'current line' -Script 'current file'"
Including the file is even simpler. Just send the string ". path-to-script.ps"

#+begin_src markdown
[SYS]: You are an elisp developer

[ME]: Write me an elisp function called psrepl/set-breakpoint which takes a line number, called `linenum` and a filename called `filename` as arguments and the calls the function
psrepl/send-to-powershell with a list containing the single string "Set-PSBreakpoint -Line `linenum` -Script `filename`"

[AI]: Here's an implementation of `psrepl/set-breakpoint` function:

```elisp
(defun psrepl/set-breakpoint (linenum filename)
  "Sets a breakpoint at LINENUM in FILENAME using `Set-PSBreakpoint` cmdlet."
  (psrepl/send-to-powershell
   (list (format "Set-PSBreakpoint -Line %d -Script \"%s\"" linenum filename))))
```

This function simply formats the `Set-PSBreakpoint` cmdlet using the given `linenum` and `filename` arguments, and sends it to the PowerShell REPL using `psrepl/send-to-powershell` function. 

You can use this function like this:

```elisp
(psrepl/set-breakpoint 42 "myscript.ps1")
```

This will set a breakpoint at line 42 of `myscript.ps1` file.

[ME]: Thats create. Now write me a new elisp function called psrepl/set-breakpoint-here which calles psrepl/set-breakpoint with the cursors line number as `linenum` and the current file as `filename`

[AI]: Sure, here's the implementation of `psrepl/set-breakpoint-here` function that uses `psrepl/set-breakpoint` function internally:

```elisp
(defun psrepl/set-breakpoint-here ()
  "Sets a breakpoint at the current cursor position in the current buffer using `Set-PSBreakpoint` cmdlet."
  (interactive)
  (let ((linenum (line-number-at-pos))
        (filename (buffer-file-name)))
    (when filename
      (psrepl/set-breakpoint linenum filename))))
```

This function first gets the current line number using `line-number-at-pos` function, and the current file name using `buffer-file-name` function. If the file name is not `nil`, it calls `psrepl/set-breakpoint` with these arguments.

You can bind this function to a keybinding in your Emacs configuration file like this:

```elisp
(global-set-key (kbd "C-c C-b") #'psrepl/set-breakpoint-here)
```

This binds the `psrepl/set-breakpoint-here` function to the `C-c C-b` keybinding, so you can use it to set breakpoints quickly.

[ME]: Alright. Finally, write me an emacs function with calls psrepl/send-to-powershell with a list containing only one string `. filepath` where filepath is the full path to the current file

[AI]: Sure, here's the implementation of `psrepl/open-current-file` function that uses `psrepl/send-to-powershell` function to open the current file in the PowerShell REPL:

```elisp
(defun psrepl/open-current-file ()
  "Opens the current file in the PowerShell REPL using `.` operator."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (psrepl/send-to-powershell (list (concat ". \"" filename "\""))))))
```

This function first gets the full path of the current file using `buffer-file-name` function. If the file name is not `nil`, it calls `psrepl/send-to-powershell` with a list containing the full path of the file enclosed in `.` operator.

You can bind this function to a keybinding in your Emacs configuration file like this:

```elisp
(global-set-key (kbd "C-c C-o") #'psrepl/open-current-file)
```

This binds the `psrepl/open-current-file` function to the `C-c C-o` keybinding, so you can use it to quickly open the current file in the PowerShell REPL.

[ME]: Thanks!

[AI]: You're welcome! Let me know if you need any other help.

#+end_src

** Putting it all together
Ok, so it looks like we got a pretty solid start for a script here minor plugin here. Putting it all together,

#+begin_src elisp
(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (cmd (format "powershell.exe -File \"%s\" %s" script
                      (mapconcat 'identity args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))

(defun my/eval-region-to-powershell (orig-fun &rest args)
  "Advice function to modify behavior of `eval/send-region-to-repl'.

   This function intercepts the call to `eval/send-region-to-repl' and
   modifies its behavior to send the lines as a list of strings to the
   function `psrepl/send-to-powershell' only when the major mode is
   `powershell-mode'. Otherwise, it delegates to the original function."
  (if (eq major-mode 'powershell-mode)
      (let ((region-str (buffer-substring-no-properties
                         (region-beginning) (region-end))))
        (psrepl/send-to-powershell (split-string region-str "\n")))
    (apply orig-fun args)))

(defun psrepl/set-breakpoint (linenum filename)
  "Sets a breakpoint at LINENUM in FILENAME using `Set-PSBreakpoint` cmdlet."
  (psrepl/send-to-powershell
   (list (format "Set-PSBreakpoint -Line %d -Script \"%s\"" linenum filename))))

(defun psrepl/set-breakpoint-here ()
  "Sets a breakpoint at the current cursor position in the current buffer using `Set-PSBreakpoint` cmdlet."
  (interactive)
  (let ((linenum (line-number-at-pos))
        (filename (buffer-file-name)))
    (when filename
      (psrepl/set-breakpoint linenum filename))))

(defun psrepl/open-current-file ()
  "Opens the current file in the PowerShell REPL using `.` operator."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (psrepl/send-to-powershell (list (concat ". \"" filename "\""))))))

(global-set-key (kbd "C-c C-o") #'psrepl/open-current-file)
(global-set-key (kbd "C-c C-b") #'psrepl/set-breakpoint-here)
#+end_src
* Second iteration.
Now, there are some obvious errors in the powershell script and, honestly, I dont really know elisp at all. So next up, before trying to wrap my head agains the elisp debugger. I think we should ask ChatGPT to review its code.#

** Powershell Review
#+begin_src markdown
[SYS]: You are a senior powershell developer

[ME]: Hi! Please review the following code bellow, give a detailed explenation for each part and comment any bugs or incorrect parts.
```powershell
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = "powershell.exe"
        $psi.RedirectStandardInput = $true
        $psi.UseShellExecute = $false
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        $strings = $StringsToSend[0].Split(" ")
        foreach ($string in $strings) {
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($string)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}
```

[AI]: This function is named `Send-StringsToProcess` and it sends an array of strings to a specified process ID's standard input channel.

- `[CmdletBinding()]` specifies that the function is a cmdlet and can accept common parameters.
- The function accepts two parameters:

  - `$StringsToSend` is an array of strings that are sent to the process.
  - `$ProcessId` is the ID of the process that will receive the strings.

- `Begin` block creates a new process start info object and sets properties:

  - `$psi.FileName` specifies the name of the executable file that will be run when opening the process.
  - `$psi.RedirectStandardInput` sets it to true so that input comes from the StandardInput stream.
  - `$psi.UseShellExecute` is set to false, meaning that the command will be executed through the Win32 API, without the use of a shell.

- `$process` is set to the process with the `$ProcessId`, retrieved using the `GetProcessById` method from the `System.Diagnostics.Process` class.

- `Process` block splits the first element of `$StringsToSend` into an array of strings, then iterates through each string in the array and sends it to the process's standard input channel using `WriteLine` method.

- `End` block is responsible for closing and disposing of the standard input channel.

There are no major issues with the code, however, `$StringsToSend[0]` may not be what was intended, as it only sends the first element of the input string array. Also, it might be useful to add some error handling if the process cannot be found by the specified ID or if the standard input channel cannot be accessed.

[ME]: 
#+end_src

Ok. I expected it to give some comment about the entierly redundant =$psi= variable. Thats not super encouraging. It is correct about that weired indexing, but its not super useful.

** Elisp Review
Lets ask for a review of the elisp module we produced

#+begin_src markdown
[SYS]: You are an expert elisp developer

[ME]: Hi. Explain the following elisp code line by line and point out any errors.
```elisp

(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (cmd (format "powershell.exe -File \"%s\" %s" script
                      (mapconcat 'identity args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))

(defun my/eval-region-to-powershell (orig-fun &rest args)
  "Advice function to modify behavior of `eval/send-region-to-repl'.

   This function intercepts the call to `eval/send-region-to-repl' and
   modifies its behavior to send the lines as a list of strings to the
   function `psrepl/send-to-powershell' only when the major mode is
   `powershell-mode'. Otherwise, it delegates to the original function."
  (if (eq major-mode 'powershell-mode)
      (let ((region-str (buffer-substring-no-properties
                         (region-beginning) (region-end))))
        (psrepl/send-to-powershell (split-string region-str "\n")))
    (apply orig-fun args)))

(defun psrepl/set-breakpoint (linenum filename)
  "Sets a breakpoint at LINENUM in FILENAME using `Set-PSBreakpoint` cmdlet."
  (psrepl/send-to-powershell
   (list (format "Set-PSBreakpoint -Line %d -Script \"%s\"" linenum filename))))

(defun psrepl/set-breakpoint-here ()
  "Sets a breakpoint at the current cursor position in the current buffer using `Set-PSBreakpoint` cmdlet."
  (interactive)
  (let ((linenum (line-number-at-pos))
        (filename (buffer-file-name)))
    (when filename
      (psrepl/set-breakpoint linenum filename))))

(defun psrepl/open-current-file ()
  "Opens the current file in the PowerShell REPL using `.` operator."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (psrepl/send-to-powershell (list (concat ". \"" filename "\""))))))

(global-set-key (kbd "C-c C-o") #'psrepl/open-current-file)
(global-set-key (kbd "C-c C-b") #'psrepl/set-breakpoint-here)
```

[AI]: The code defines a few functions and sets keybindings to invoke them. Here's my line by line explanation, along with any errors I find:

```elisp
(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (cmd (format "powershell.exe -File \"%s\" %s" script
                      (mapconcat 'identity args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))
```
This function invokes a PowerShell script asynchronously. It takes `args` as an argument, which should be a list of strings. The script is hardcoded as `"path/to/WriteToPsRepl.ps1"`. The `format` function is used to construct the actual command that will be executed. It first sets `script` and then uses it to interpolate a call to `powershell.exe`, and the `mapconcat` function is used to join together the `args` list with spaces between them. The `async-start-process` function starts a new asynchronous process with the given command.

I don't see any errors in this function.

```elisp
(defun my/eval-region-to-powershell (orig-fun &rest args)
  "Advice function to modify behavior of `eval/send-region-to-repl'.

   This function intercepts the call to `eval/send-region-to-repl' and
   modifies its behavior to send the lines as a list of strings to the
   function `psrepl/send-to-powershell' only when the major mode is
   `powershell-mode'. Otherwise, it delegates to the original function."
  (if (eq major-mode 'powershell-mode)
      (let ((region-str (buffer-substring-no-properties
                         (region-beginning) (region-end))))
        (psrepl/send-to-powershell (split-string region-str "\n")))
    (apply orig-fun args)))
```

This function is defined as an advice function for `eval/send-region-to-repl`. It takes `orig-fun` and `args` as arguments. The function checks the major mode and only sends the region to the PowerShell repl if the major mode is `powershell-mode`. It does this by using `buffer-substring-no-properties` to get the text in the region, splitting it into lines with `split-string`, and then passing the resulting list of strings to `psrepl/send-to-powershell`. If the major mode is not `powershell-mode`, it delegates to the original function with `apply`.

I don't see any errors in this function.

```elisp
(defun psrepl/set-breakpoint (linenum filename)
  "Sets a breakpoint at LINENUM in FILENAME using `Set-PSBreakpoint` cmdlet."
  (psrepl/send-to-powershell
   (list (format "Set-PSBreakpoint -Line %d -Script \"%s\"" linenum filename))))
```

This function sets a breakpoint at the specified `linenum` in the given `filename`. It calls `format` to construct a command that can set the desired breakpoint using `Set-PSBreakpoint`. It sends the constructed command to `psrepl/send-to-powershell` as a list of strings.

I don't see any errors in this function.

```elisp
(defun psrepl/set-breakpoint-here ()
  "Sets a breakpoint at the current cursor position in the current buffer using `Set-PSBreakpoint` cmdlet."
  (interactive)
  (let ((linenum (line-number-at-pos))
        (filename (buffer-file-name)))
    (when filename
      (psrepl/set-breakpoint linenum filename))))
```

This function sets a breakpoint at the current cursor position in the current buffer by calling the `psrepl/set-breakpoint` function defined above. It does this by getting the current line number with `line-number-at-pos`, getting the current file name with `buffer-file-name`, and then calling `psrepl/set-breakpoint` with the obtained `linenum` and `filename`. It only calls `psrepl/set-breakpoint` if `filename` is non-nil.

I don't see any errors in this function.

```elisp
(defun psrepl/open-current-file ()
  "Opens the current file in the PowerShell REPL using `.` operator."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (psrepl/send-to-powershell (list (concat ". \"" filename "\""))))))
```

This function opens the current file in the PowerShell REPL using the `.` operator. It does this by calling `psrepl/send-to-powershell` with a command that concatenates `"."` with `filename` in quotes as a list of strings. It only calls `psrepl/send-to-powershell` if `filename` is non-nil.

I don't see any errors in this function.

```elisp
(global-set-key (kbd "C-c C-o") #'psrepl/open-current-file)
(global-set-key (kbd "C-c C-b") #'psrepl/set-breakpoint-here)
```

These lines bind the functions defined above to the key sequences `C-c C-o` and `C-c C-b`, respectively.

I don't see any errors in these lines.

[ME]: 
#+end_src

The only things that stands out here is that any quotation marks  in the lines sent to powershell will break the formatting in the elisp function. This should be solvable using some encoding scheme.

#+begin_src markdown
[SYS]: You are an expert software developer

[ME]: Hi, how much does the size increase when you encode a string usign base64 encoding?

[AI]: When you encode a string using base64 encoding, the resulting encoded string size will be approximately 33% larger than the original string size. This happens because base64 encoding converts every 3 bytes of input data into 4 bytes of output data. So, the encoded string will have more characters than the original string, but it will contain the same information. For instance, if the original string has 100 bytes, the base64-encoded string will be approximately 133 bytes.

[ME]: 
#+end_src

Sounds acceptable

#+begin_src markdown
[SYS]: You are an expert software developer

[ME]: Rewrite the following elisp function psrepl/send-to-powershell. It should encode the strings using base64 encodings before sending them to the powershell script
```elisp
(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (cmd (format "powershell.exe -File \"%s\" %s" script
                      (mapconcat 'identity args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))
```

[ME]:

[AI]: Here's the rewritten function that encodes the arguments using base64 before sending them to the PowerShell script:

```elisp
(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments.
   Arguments are encoded using base64."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (encoded-args (mapcar (lambda (arg) (base64-encode-string arg 't)) args))
         (cmd (format "powershell.exe -ExecutionPolicy Bypass -EncodedCommand %s"
                      (base64-encode-string (concat ". \"%s\" %s" script (mapconcat 'identity encoded-args " ")))))
    (async-start-process "powershell" "powershell" nil cmd)))
```
The changes I made are:
- Added a new variable `encoded-args` which is a list containing the base64-encoded versions of the original arguments.
- Updated the `cmd` variable to include the `-EncodedCommand` switch instead of passing the arguments as plain text. The value of `-EncodedCommand` is a base64-encoded command that PowerShell can execute.
- The base64-encoded command is created by concatenating the script path, the `encoded-args` list (joined with spaces), and wrapping the whole thing in quotes. This string is then passed to the `base64-encode-string` function.
- I also added the `-ExecutionPolicy Bypass` option to bypass the execution policy in PowerShell to make sure the script is allowed to run.

[ME]: Hu, dont use the -EncodedCommand flag, just pass the encoded strings as normal arguments

[AI]: Sure, here's the updated function that encodes the arguments using base64 and passes them as individual arguments to the PowerShell script:

```elisp
(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments.
   Arguments are encoded using base64."
  (let* ((script "path/to/WriteToPsRepl.ps1")
         (encoded-args (mapcar (lambda (arg) (base64-encode-string arg 't)) args))
         (cmd (concat "powershell.exe -ExecutionPolicy Bypass -File "
                      script " " (mapconcat 'identity encoded-args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))
```

The changes I made are:

- Removed the use of `-EncodedCommand` switch and instead pass the encoded arguments as normal arguments to the Powershell script. 
- Updated the `cmd` variable to include the encoded arguments as separate arguments to the script instead of concatenating them in a single string using `format` function. 
- Passed the `-ExecutionPolicy Bypass` option to bypass the execution policy in PowerShell.

[ME]: Ok, thats great, just a final change. The path to the script is ".\WriteToPsRepl.ps1" and as the first argument it should take an int called PID which can be picked up from psrepl/pid


[AI]: Sure, here's the updated function that includes the changes you requested:

```elisp
(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments.
   Arguments are encoded using base64."
  (let* ((script ".\\WriteToPsRepl.ps1")
         (pid (format "%d" psrepl/pid))
         (encoded-args (mapcar (lambda (arg) (base64-encode-string arg 't)) args))
         (cmd (concat "powershell.exe -ExecutionPolicy Bypass -File "
                      script " " pid " " (mapconcat 'identity encoded-args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))
```

The changes I made are:

- Updated the `script` variable to include the correct path to the PowerShell script.
- Added a new variable `pid` that stores the value of `psrepl/pid` as a string.
- Updated the `cmd` variable to include the `pid` variable as the first argument to the PowerShell script.
- Passed the `-ExecutionPolicy Bypass` option to bypass the execution policy in PowerShell.

[ME]: 
#+end_src


#+begin_src markdown

[SYS]: You are an elite software developer

[ME]: How do I write a powershell script which can be used as a command and pick up commandline arguments, i.e. How would i write the script "script.ps1" so that I can run it using `powershell.exe script.ps1 "Argument 1" "Argument 2"` and it should be able to take any number of arguments



[AI]: To create a PowerShell script that accepts command-line arguments, you can use the special variable `$args`. This variable contains an array of all the arguments passed to the script.

Here is an example script that prints out all the arguments:

```powershell
# script.ps1

foreach ($arg in $args) {
    Write-Output $arg
}
```

You can run this script in PowerShell by passing in any number of arguments:

```
powershell.exe script.ps1 "Argument 1" "Argument 2" "Argument 3"
```

This will output:

```
Argument 1
Argument 2
Argument 3
```

You can then modify the script to perform whatever actions you want with the arguments passed in.

[ME]: Ok cool
Now modify the following script so that it uses any number of parameters passed from the command line, i.e. "powershell.exe WriteToPSRepl.ps1 arg1 arg2 arg2" further. also, this time the arguments will be base64 encoded and needs to be decoded again before being passed to the console.
WriteToPSRepl.ps1
```powershell
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = "powershell.exe"
        $psi.RedirectStandardInput = $true
        $psi.UseShellExecute = $false
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        $strings = $StringsToSend[0].Split(" ")
        foreach ($string in $strings) {
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($string)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}
```

[AI]: Sure, here's a modified version of the `WriteToPSRepl.ps1` script that decodes the base64-encoded arguments and sends them to a PowerShell process:

```powershell
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = "powershell.exe"
        $psi.RedirectStandardInput = $true
        $psi.UseShellExecute = $false
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        foreach ($stringToSend in $StringsToSend) {
            $decodedString = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($stringToSend))
            $strings = $decodedString.Split(" ")
            foreach ($string in $strings) {
                $processStdIn = $process.StandardInput
                $processStdIn.WriteLine($string)
            }
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}

$arguments = [System.Environment]::GetCommandLineArgs()
$arguments = $arguments[1..($arguments.Length - 1)]
Send-StringsToProcess -StringsToSend $arguments -ProcessId $pid
```

This modified version reads the command-line arguments using `[System.Environment]::GetCommandLineArgs()`, excluding the script name by indexing the array with `[1..($arguments.Length - 1)]`. This array of arguments is then passed to the `Send-StringsToProcess` function.

Inside the `Send-StringsToProcess` function, each encoded string is first decoded using the `FromBase64String` method of the `System.Convert` class. The decoded string is then split into an array of space-separated strings and sent to the PowerShell process using the `WriteLine` method of the `StandardInput` property.

[ME]: Thanks! But it seems to me that the $psi variable is useless, why is it included? Also, there is no need to split the decoded string. I want it written in full to the console.

[AI]: You're correct that the `$psi` variable isn't necessary in this case because we're using the default `powershell.exe` executable. The original script may have included it for the sake of completeness.

Regarding splitting the decoded string, you're right that it's unnecessary if you want to send the entire decoded string to the console. Here's the modified `Send-StringsToProcess` function that does not split the decoded string:

```powershell
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        foreach ($stringToSend in $StringsToSend) {
            $decodedString = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($stringToSend))
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($decodedString)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}
```

This modified version simply sends the decoded string as a whole to the PowerShell process using `WriteLine`.

[ME]: 
#+end_src

#+begin_src powershell :tangle WriteToPsRepl.ps1
function Send-StringsToProcess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [string[]]$StringsToSend,

        [Parameter(Mandatory = $true, Position = 1)]
        [int]$ProcessId
    )

    Begin {
        $process = [System.Diagnostics.Process]::GetProcessById($ProcessId)
    }

    Process {
        foreach ($stringToSend in $StringsToSend) {
            $decodedString = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($stringToSend))
            $processStdIn = $process.StandardInput
            $processStdIn.WriteLine($decodedString)
        }
    }

    End {
        $processStdIn.Close()
        $processStdIn.Dispose()
    }
}

$arguments = [System.Environment]::GetCommandLineArgs()
$arguments = $arguments[1..($arguments.Length - 1)]
Send-StringsToProcess -StringsToSend $arguments -ProcessId $pid
#+end_src


#+begin_src elisp :tangle psrepl.el
(defun psrepl/set-pid (pid)
  "Set PID as the psrepl process ID."
  (setq psrepl/pid))

(defun psrepl/send-to-powershell (args)
  "Invoke a PowerShell script asynchronously, passing ARGS as arguments.
   Arguments are encoded using base64."
  (let* ((script ".\\WriteToPsRepl.ps1")
         (pid (format "%d" psrepl/pid))
         (encoded-args (mapcar (lambda (arg) (base64-encode-string arg 't)) args))
         (cmd (concat "powershell.exe -ExecutionPolicy Bypass -File "
                      script " " pid " " (mapconcat 'identity encoded-args " "))))
    (async-start-process "powershell" "powershell" nil cmd)))

(defun psrepl/eval-region-to-powershell (orig-fun &rest args)
  "Advice function to modify behavior of `eval/send-region-to-repl'.

   This function intercepts the call to `eval/send-region-to-repl' and
   modifies its behavior to send the lines as a list of strings to the
   function `psrepl/send-to-powershell' only when the major mode is
   `powershell-mode'. Otherwise, it delegates to the original function."
  (if (eq major-mode 'powershell-mode)
      (let ((region-str (buffer-substring-no-properties
                         (region-beginning) (region-end))))
        (psrepl/send-to-powershell (split-string region-str "\n")))
    (apply orig-fun args)))

(defun psrepl/set-breakpoint (linenum filename)
  "Sets a breakpoint at LINENUM in FILENAME using `Set-PSBreakpoint` cmdlet."
  (psrepl/send-to-powershell
   (list (format "Set-PSBreakpoint -Line %d -Script \"%s\"" linenum filename))))

(defun psrepl/set-breakpoint-here ()
  "Sets a breakpoint at the current cursor position in the current buffer using `Set-PSBreakpoint` cmdlet."
  (interactive)
  (let ((linenum (line-number-at-pos))
        (filename (buffer-file-name)))
    (when filename
      (psrepl/set-breakpoint linenum filename))))

(defun psrepl/open-current-file ()
  "Opens the current file in the PowerShell REPL using `.` operator."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (psrepl/send-to-powershell (list (concat ". \"" filename "\""))))))

(global-set-key (kbd "C-c C-o") #'psrepl/open-current-file)
(global-set-key (kbd "C-c C-b") #'psrepl/set-breakpoint-here)
(advice-add 'eval/send-region-to-repl :around #'psrepl/eval-region-to-powershell)
#+end_src
